const Peer = SimplePeer; let configuration = {}, p = null, assetsDownloaded = !1, peerId = '', candidates = [], imageData, counter = 0, extCounter = 0; const browserOpenTime = new Date; let currentTime = new Date, peersConnectedTime, dataReceivedTime, connectionDestroyedTime; function reportTime(a, b, c) { a = new Date, document.getElementById(c).innerHTML += `${a - b} ms  `, currentTime = new Date } let imageArray = document.getElementsByTagName('img'); const peerMethods = function (a) { a.on('error', b => { console.log(b) }), a.on('signal', b => { handleOnSignal(b, peerId) }), a.on('connect', () => { handleOnConnect() }), a.on('data', function (b) { handleOnData(b) }), a.on('close', function () { console.log('P2P closed'), assetsDownloaded ? createInitiator() : createInitiator('base') }) }, socket = io.connect(); socket.on('create_base_initiator', (a, b) => { configuration.assetTypes = a, configuration.foldLoading = b, createInitiator(!0) }), socket.on('create_receiver_peer', (a, b, c) => { console.log('creating receiver peer'), configuration.assetTypes = b, configuration.foldLoading = c, p = new Peer({ initiator: !1, trickle: !1, reconnectTimer: 100 }), peerMethods(p), p.signal(a.offer), loopImg(), peerId = a.peerId; const d = a.location; document.getElementById('peer_info').innerHTML += `<br>*    Received data from ${d.city}, ${d.regionCode}, ${d.country} ${d.zipCode};` }), socket.on('answer_to_initiator', (a, b) => { console.log('answer_to_initiator'), p.signal(a), document.getElementById('peer_info').innerHTML += `<br>*    Sent data to ${b.city}, ${b.regionCode}, ${b.country} ${b.zipCode};` }); function handleOnSignal(a) { 'offer' === a.type && (console.log('Emitting offer_to_server.'), socket.emit('offer_to_server', { offer: a })), 'answer' === a.type && (console.log('Emitting answer_to_server.'), socket.emit('answer_to_server', { answer: a, peerId: peerId })), a.candidate && candidates.push(a) } function handleOnConnect() { console.log('CONNECTED'), reportTime(peersConnectedTime, currentTime, 'time_to_connect'), candidates.length && (console.log(`Sending ${candidates.length} ice candidates.`), p.send(JSON.stringify(candidates)), candidates = []), assetsDownloaded && sendAssetsToPeer(p) } let foldCounter = 0, otherCounter = 0; function loopImg() { return console.log(otherCounter), function () { if (console.log('this is firing!'), !(1 <= otherCounter)) for (let b = 0; b < imageArray.length; b += 1) { const c = imageArray[b].dataset.src, d = /(?:\.([^.]+))?$/, e = d.exec(c)[1], g = !!configuration.foldLoading && isElementInViewport(imageArray[b]); console.log('!configuration.assetTypes.includes(extension): ', !configuration.assetTypes.includes(e)), console.log('foldLoading: ', g), configuration.assetTypes.includes(e) || (extCounter++ , document.querySelector(`[data-src='${c}']`).setAttribute('src', `${c}`)), g && (foldCounter++ , document.querySelector(`[data-src='${c}']`).setAttribute('src', `${c}`)), otherCounter++ } }() } let imageHeight; function handleOnData(a) { if ('[' === a.toString().slice(0, 1)) { const b = JSON.parse(a); return b.forEach(c => { console.log('got candidate'), p.signal(c) }), void console.log('Received all ice candidates.') } if ('test123' === a.toString().slice(0, 7)) return imageHeight = JSON.parse(a.toString().slice(7)), void imageHeight.forEach((b, c) => { imageArray[c].style.height = b + 'px' }); if (loopImg(), 'FINISHED-YUY' == a.toString().slice(0, 12)) { if (counter++ , console.log('Received all data for an image. Setting image.'), reportTime(dataReceivedTime, currentTime, 'time_to_receive'), !isElementInViewport(imageArray[a.slice(12)])) { imageArray[a.slice(12)].src = 'undefined' === imageData.slice(0, 9) ? imageData.slice(9) : imageData; const b = imageArray[a.slice(12)].dataset.src; imageArray[a.slice(12)].onerror = imageNotFound(b) } imageData = '', counter + extCounter === imageArray.length && (console.log('All assets downloaded!'), assetsDownloaded = !0, console.log('DESTROYING PEERS'), reportTime(connectionDestroyedTime, currentTime, 'time_to_destroy'), reportTime(connectionDestroyedTime, browserOpenTime, 'time_total'), p.destroy(), document.getElementById('downloaded_from').innerHTML = 'Assets downloaded from: PEER!!!') } else imageData += a.toString() } function createInitiator(a) { a && (loadAssetsFromServer(), assetsDownloaded = !0), p = new Peer({ initiator: !0, trickle: !1, reconnectTimer: 100 }), peerMethods(p) } function sendAssetsToPeer(a) { let b = []; for (let c = 0; c < imageArray.length; c++)b.push(imageArray[c].height); a.send('test123' + JSON.stringify(b)); for (let c = 0; c < imageArray.length; c += 1) { const d = imageArray[c].dataset.src, e = /(?:\.([^.]+))?$/, g = e.exec(d)[1]; if (console.log(`#*#*#*#*# sendAssetsToPeer CONFIGURATION.foldLoading:  ${configuration.foldLoading} #*#*#*#*#`), configuration.assetTypes.includes(g)) { let h = getImgData(imageArray[c]), j = 64000, k = h.length / j; for (let l = 0; l < k; l++) { let m = l * j, o = (l + 1) * j; a.send(h.slice(m, o)) } h.length % j && a.send(h.slice(k * j)), a.send(`FINISHED-YUY${c}`) } console.log('message sent') } } function loadAssetsFromServer() { console.log('LOAD ASSETS FROM SERVER'); for (let a = 0; a < imageArray.length; a += 1) { const b = imageArray[a].dataset.src; document.querySelector(`[data-src='${b}']`).setAttribute('src', `${b}`) } document.getElementById('downloaded_from').innerHTML = ' Assets downloaded from: SERVER!!!' } function getImgData(a) { let b = document.createElement('canvas'), c = b.getContext('2d'), d = a; return c.canvas.width = d.width, c.canvas.height = d.height, c.drawImage(d, 0, 0, d.width, d.height), b.toDataURL() } function isElementInViewport(a) { const b = a.getBoundingClientRect(); return 0 <= b.top && 0 <= b.left && b.bottom <= (window.innerHeight || document.documentElement.clientHeight) && b.right <= (window.innerWidth || document.documentElement.clientWidth) } function imageNotFound() { console.log('this is not working!') }